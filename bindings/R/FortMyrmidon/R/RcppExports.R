# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

pfmValueType <- function(v) {
    .Call(`_FortMyrmidon_pfmValueType`, v)
}

pfmBool <- function() {
    .Call(`_FortMyrmidon_pfmBool`)
}

pfmInt <- function() {
    .Call(`_FortMyrmidon_pfmInt`)
}

pfmDouble <- function() {
    .Call(`_FortMyrmidon_pfmDouble`)
}

pfmString <- function() {
    .Call(`_FortMyrmidon_pfmString`)
}

pfmTime <- function() {
    .Call(`_FortMyrmidon_pfmTime`)
}

#' Returns myrmidon's default collection of colors
#' @return a list of RGB 8-bit triplets
#' @family fmColor methods
fmDefaultPalette <- function() {
    .Call(`_FortMyrmidon_fmDefaultPalette`)
}

#' Returns myrmidon' default color for index, wrapping arround
#' @param index the wanted index
#' @return a list of RGB 8-bit triplets
#' @family fmColor methods
fmDefaultPaletteColor <- function(index) {
    .Call(`_FortMyrmidon_fmDefaultPaletteColor`, index)
}

#' Creates a fmVector2dList from a list of numerical vector or a data.frame
#' @param points a list of numerical vector of size 2 or a data.frame with column 'x' and 'y'
#' @return a fmVector2dList
#' @family fmVector2dList methods
fmVector2dListCreate <- function(points = NULL) {
    .Call(`_FortMyrmidon_fmVector2dListCreate`, points)
}

pfmIWantAVector2dList <- function(l) {
    invisible(.Call(`_FortMyrmidon_pfmIWantAVector2dList`, l))
}

#' @title Creates an Experiement.
#' @description No file will be created a filepath, but it is
#'   required to determine relative path to the eventual Tracking
#'   Data Directory that will be added to the experiment.
#' @param filepath to use for the experiment.
#' @return a \code{\link{fmExperiment}} with the associated filepath
#' @family fmExperiment methods
fmExperimentCreate <- function(filepath) {
    .Call(`_FortMyrmidon_fmExperimentCreate`, filepath)
}

#' Opens an Experiment
#' @param filepath the path to the '.myrmidon' file
#' @return a \code{\link{fmExperiment}}
#' @family fmExperiment methods
fmExperimentOpen <- function(filepath) {
    .Call(`_FortMyrmidon_fmExperimentOpen`, filepath)
}

#' Formats an AntID
#' @param antID the AntID to format
#' @return a character with the formatted ID
fmFormatAntID <- function(antID) {
    .Call(`_FortMyrmidon_fmFormatAntID`, antID)
}

#' Formats a TagID
#' @param tagID the TagID to format
#' @return a character with the formatted ID
fmFormatTagID <- function(tagID) {
    .Call(`_FortMyrmidon_fmFormatTagID`, tagID)
}

#' A fmMatcher that matches anything
#' @return a \code{\link{fmMatcher}} that matches everything.
#' @family fmMatcher methods
fmMatcherAny <- function() {
    .Call(`_FortMyrmidon_fmMatcherAny`)
}

#' Combines fmMatcher in conjunction
#' @param matchers the \code{\link{fmMatcher}} to combine
#' @return a \code{\link{fmMatcher}} that matches when all
#'   **matchers** matches.
#' @family fmMatcher methods
fmMatcherAnd <- function(matchers) {
    .Call(`_FortMyrmidon_fmMatcherAnd`, matchers)
}

#' Combines fmMatcher in disjunction
#' @param matchers the \code{\link{fmMatcher}} to combine
#' @return a \code{\link{fmMatcher}} that matches when any of the
#'   **matchers** matches.
#' @family fmMatcher methods
fmMatcherOr <- function(matchers) {
    .Call(`_FortMyrmidon_fmMatcherOr`, matchers)
}

#' A fmMatcher that matches AntID
#' @details In the case of interactions, matches interaction with one
#'   of the Ant having **antID**.
#' @param antID the Ant ID to match
#' @return a \code{\link{fmMatcher}} that matches when one of the
#'   considered Ant is **antID**
#' @family fmMatcher methods
fmMatcherAntID <- function(antID) {
    .Call(`_FortMyrmidon_fmMatcherAntID`, antID)
}

#' A fmMatcher that matches metadata key/value
#' @details In the case of interactions, matches interaction with one
#'   of the Ant meeting the criterion.
#' @param key the key to match
#' @param value the value to match. Should either be a logical,
#'   integer, numerical, character or \code{\link{fmTime}}.
#' @return a \code{\link{fmMatcher}} that matches when one of the
#'   considered Ant is has **key** equal to **value**.
#' @family fmMatcher methods
fmMatcherAntMetaData <- function(key, value) {
    .Call(`_FortMyrmidon_fmMatcherAntMetaData`, key, value)
}

#' A fmMatcher that matches ants distances
#' @details In the case of trajectories, it matches anything.
#' @param distance the distance in pixel to be smaller
#' @return a \code{\link{fmMatcher}} that matches when two Ant lies
#'   within the given distance.
#' @family fmMatcher methods
fmMatcherAntDistanceSmallerThan <- function(distance) {
    .Call(`_FortMyrmidon_fmMatcherAntDistanceSmallerThan`, distance)
}

#' A fmMatcher that matches ants distances
#' @details In the case of trajectories, it matches anything.
#' @param distance the distance in pixel to be greater
#' @return a \code{\link{fmMatcher}} that matches when two Ant lies
#'   apart of the given distance.
#' @family fmMatcher methods
fmMatcherAntDistanceGreaterThan <- function(distance) {
    .Call(`_FortMyrmidon_fmMatcherAntDistanceGreaterThan`, distance)
}

#' A fmMatcher that matches ants angles
#' @details In the case of trajectories, it matches anything.
#' @param angle the angle in radians to be smaller
#' @return a \code{\link{fmMatcher}} that matches when the absolute
#'     angle between two Ant is smaller than **angle**.
#' @family fmMatcher methods
fmMatcherAntAngleSmallerThan <- function(angle) {
    .Call(`_FortMyrmidon_fmMatcherAntAngleSmallerThan`, angle)
}

#' A fmMatcher that matches ants angles
#' @details In the case of trajectories, it matches anything.
#' @param angle the angle in radians to be larger
#' @return a \code{\link{fmMatcher}} that matches when the absolute
#'     angle between two Ant is larger than **angle**.
#' @family fmMatcher methods
fmMatcherAntAngleGreaterThan <- function(angle) {
    .Call(`_FortMyrmidon_fmMatcherAntAngleGreaterThan`, angle)
}

#' A fmMatcher that matches interaction types
#' @details In the case of trajectories, it matches anything.
#' @param type1 the first ant shape type to match
#' @param type2 the second ant shape type to match
#' @return a \code{\link{fmMatcher}} that matches
#'     (**type1**,**type2**) and (**type2**,**type1**) interactions.
#' @family fmMatcher methods
fmMatcherInteractionType <- function(type1, type2) {
    .Call(`_FortMyrmidon_fmMatcherInteractionType`, type1, type2)
}

#' A fmMatcher that matches ant displacement
#' @param under the maximal allowed displacement in pixel
#' @param minimumGap minimal time Gap between check
#' @description Matches trajectories and interactions where the Ant
#'     displacement between two consecutive position is smaller than
#'     **under**. If **minimumGap** is not zero, this check will be
#'     enforced only if there was at least a duration of **minimumGap**
#'     between two consecutive positions.
#' @return a \code{\link{fmMatcher}} that rejects large displacement
#'   in a tracking gap.
#' @family fmMatcher methods
fmMatcherAntDisplacement <- function(under, minimumGap) {
    .Call(`_FortMyrmidon_fmMatcherAntDisplacement`, under, minimumGap)
}

#' Queries manual measurements for an Ant
#' @param experiment the \code{\link{fmExperiment}} to query
#' @param antID the ant to compute for
#' @param typeID the wanted measurement type
#' @return a data.frame with the date of the measurement and
#'   estimated size in millimeters and pixels.
#' @family fmQuery methods
fmQueryComputeMeasurementFor <- function(experiment, antID, typeID = 1L) {
    .Call(`_FortMyrmidon_fmQueryComputeMeasurementFor`, experiment, antID, typeID)
}

#' Computes tag statistics for an experiment
#' @param experiment the \code{\link{fmExperiment}} to query
#' @return a \code{data.frame} with the detection statistics in
#'   **experiment**
#' @family fmQuery methods
fmQueryComputeTagStatistics <- function(experiment) {
    .Call(`_FortMyrmidon_fmQueryComputeTagStatistics`, experiment)
}

pfmQueryIdentifyFrames <- function(experiment, start, end, computeZones, showProgress, singleThreaded) {
    .Call(`_FortMyrmidon_pfmQueryIdentifyFrames`, experiment, start, end, computeZones, showProgress, singleThreaded)
}

pfmQueryCollideFrames <- function(experiment, start, end, collisionsIgnoreZones, showProgress, singleThreaded) {
    .Call(`_FortMyrmidon_pfmQueryCollideFrames`, experiment, start, end, collisionsIgnoreZones, showProgress, singleThreaded)
}

pfmQueryComputeAntTrajectories <- function(experiment, start, end, maximumGap, matcher, computeZones, showProgress, singleThreaded) {
    .Call(`_FortMyrmidon_pfmQueryComputeAntTrajectories`, experiment, start, end, maximumGap, matcher, computeZones, showProgress, singleThreaded)
}

pfmQueryComputeAntInteractions <- function(experiment, start, end, maximumGap, matcher, collisionsIgnoreZones, reportFullTrajectories, showProgress, singleThreaded) {
    .Call(`_FortMyrmidon_pfmQueryComputeAntInteractions`, experiment, start, end, maximumGap, matcher, collisionsIgnoreZones, reportFullTrajectories, showProgress, singleThreaded)
}

#' Collects tracking data information on the fmExperiment
#' @param experiment the \code{\link{fmExperiment}} to query
#' @return a names list with the following items:
#'   \itemize{\code{$frames}: the total number of
#'   frames.\item\code{$start} the first tracked time in the
#'   experiment. \item\code{$end} the last tracked
#'   time. \item\code{$details}: a \code{data.frame} listing the start,
#'   end and number of frame in each tracking data directory and space of
#'   the experiment.}
#' @family fmQuery methods
fmQueryGetDataInformations <- function(experiment) {
    .Call(`_FortMyrmidon_fmQueryGetDataInformations`, experiment)
}

#' get time ranges where a metadata key has a given value
#' @param experiment the \code{\link{fmExperiment}} to query
#' @param key the key to query for
#' @param value the value to test for
#' @return a data.frame with the antID, and the start and end time
#'    where key is equal to value.
#' @family fmQuery methods
fmQueryGetMetaDataKeyRanges <- function(experiment, key, value) {
    .Call(`_FortMyrmidon_fmQueryGetMetaDataKeyRanges`, experiment, key, value)
}

#' Creates a fmShapeList
#' @param shapes the shape in the list. should be a list of fmCircle,
#'   fmCapsule or fmPolygon.
#' @return a closed \code{\link{fmShapeList}} with the given shapes
#' @family fmShape methods and classes
fmShapeListCreate <- function(shapes = NULL) {
    .Call(`_FortMyrmidon_fmShapeListCreate`, shapes)
}

pfmIWantAShapeList <- function(l) {
    invisible(.Call(`_FortMyrmidon_pfmIWantAShapeList`, l))
}

#' Creates a fmTime from an offset in second from the system's epoch
#'
#' @param offset the offset in second, Inf and -Inf are valid and
#'   respectively represents fmTimeForever() and fmTimeSinceEver().
#' @return the \code{\link{fmTime}} offseted by offset seconds from
#'   the system's epoch
#' @family fmTime methods
fmTimeCreate <- function(offset = 0.0) {
    .Call(`_FortMyrmidon_fmTimeCreate`, offset)
}

#' Returns current time as a fmTime
#'
#' @return the current time as a \code{\link{fmTime}}
#' @family fmTime methods
fmTimeNow <- function() {
    .Call(`_FortMyrmidon_fmTimeNow`)
}

#' The +∞ time
#'
#' @return a \code{\link{fmTime}} representing +∞.
#' @family fmTime methods
fmTimeForever <- function() {
    .Call(`_FortMyrmidon_fmTimeForever`)
}

#' The -∞ time
#'
#' @return a \code{\link{fmTime}} representing -∞.
#' @family fmTime methods
fmTimeSinceEver <- function() {
    .Call(`_FortMyrmidon_fmTimeSinceEver`)
}

#' Parses a time from a RFC3339 string representation
#' @description Parses a time from a RFC3339 (
#'   i.e. '1970-01-01T00:00:00.000Z' for UNIX epoch) string
#'   representation to a fmTime
#' @param input the string to parse
#' @examples
#' fmTimeParse('1970-01-01T00:00:00.000Z')$equals(fmTimeCreate()) # will be TRUE on UNIX systems
#' @return a \code{\link{fmTime}} representing \code{input}.
#' @family fmTime methods
fmTimeParse <- function(input) {
    .Call(`_FortMyrmidon_fmTimeParse`, input)
}

#' Parses a string to a fmDuration
#' @param input a string in the format `[amount][unit]` as a
#'   duration. Valid units are 'h','m','s','ms','us','ns'. The
#'   pattern can be repeated (i.e. '4m32s' is valid).
#' @examples
#' fmDurationParse("1m2s")$show() == '1m2s'
#' @return a \code{\link{fmDuration}} that is equal to input
#' @family fmDuration methods
fmDurationParse <- function(input) {
    .Call(`_FortMyrmidon_fmDurationParse`, input)
}

#' A fmDuration in hours
#' @param h an amount of hours
#' @examples
#' fmHour(1.32)
#' fmHour(-3.2) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{h} hours
#' @family fmDuration methods
fmHour <- function(h) {
    .Call(`_FortMyrmidon_fmHour`, h)
}

#' A fmDuration in minutes
#' @param m an amount of minutes
#' @examples
#' fmMinute(1.32)
#' fmMinute(-3.2) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{m} minutes
#' @family fmDuration methods
fmMinute <- function(m) {
    .Call(`_FortMyrmidon_fmMinute`, m)
}

#' A fmDuration in seconds
#' @param s an amount of seconds
#' @examples
#' fmSecond(1.32)
#' fmSecond(-3.2) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{s} seconds
#' @family fmDuration methods
fmSecond <- function(s) {
    .Call(`_FortMyrmidon_fmSecond`, s)
}

#' A fmDuration in milliseconds
#' @param ms an amount of milliseconds
#' @examples
#' fmMillisecond(1.32)
#' fmMillisecond(-3.2) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{ms} milliseconds
#' @family fmDuration methods
fmMillisecond <- function(ms) {
    .Call(`_FortMyrmidon_fmMillisecond`, ms)
}

#' A fmDuration in microseconds
#' @param us an amount of microseconds
#' @examples
#' fmMicrosecond(1.32)
#' fmMicrosecond(-3.2) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{us} microsecond
#' @family fmDuration methods
fmMicrosecond <- function(us) {
    .Call(`_FortMyrmidon_fmMicrosecond`, us)
}

#' A fmDuration in nanosecond
#' @description the smallest fmDuration representation. can only take integer values
#' @param ns an INTEGER amount of nanoseconds
#' @examples
#' fmNanosecond(1)
#' fmNanosecond(-3) # fmDuration can be negative
#' @return a \code{\link{fmDuration}} that is equal to \code{ns} nanosecond
#' @family fmDuration methods
fmNanosecond <- function(ns) {
    .Call(`_FortMyrmidon_fmNanosecond`, ns)
}

