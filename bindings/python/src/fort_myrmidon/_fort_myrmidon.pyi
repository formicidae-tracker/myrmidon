import collections.abc
import numpy
import numpy.typing
import typing
from typing import Any, ClassVar, overload

PREDECENCE_HIGHER: ZonePriority
PREDECENCE_LOWER: ZonePriority
__version__: str

class Ant:
    class DisplayState:
        __members__: ClassVar[dict] = ...  # read-only
        HIDDEN: ClassVar[Ant.DisplayState] = ...
        SOLO: ClassVar[Ant.DisplayState] = ...
        VISIBLE: ClassVar[Ant.DisplayState] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    DisplayColor: tuple[int, int, int]
    DisplayStatus: Ant.DisplayState
    def __init__(self, *args, **kwargs) -> None: ...
    def AddCapsule(self, shapeTypeID: typing.SupportsInt, capsule: Capsule) -> None: ...
    def ClearCapsules(self) -> None: ...
    def DeleteCapsule(self, index: typing.SupportsInt) -> None: ...
    def DeleteValue(self, key: str, time: Time) -> None: ...
    def GetValue(self, key: str, time: Time) -> bool | int | float | str | Time: ...
    def GetValues(self, key: str) -> list[tuple[Time, bool | int | float | str | Time]]: ...
    def IdentifiedAt(self, time: Time) -> int: ...
    def SetValue(self, key: str, value: bool | typing.SupportsInt | typing.SupportsFloat | str | Time, time: Time) -> None: ...
    @property
    def Capsules(self) -> list[tuple[int, Capsule]]: ...
    @property
    def ID(self) -> int: ...
    @property
    def Identifications(self) -> list[Identification]: ...

class AntInteraction:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def End(self) -> Time: ...
    @property
    def IDs(self) -> tuple[int, int]: ...
    @property
    def Space(self) -> int: ...
    @property
    def Start(self) -> Time: ...
    @property
    def Trajectories(self) -> tuple[AntTrajectorySegment, AntTrajectorySegment] | tuple[AntTrajectorySummary, AntTrajectorySummary]: ...
    @property
    def Types(self) -> typing.Annotated[numpy.typing.NDArray[numpy.uint32], '[m, 2]']: ...

class AntTrajectory:
    def __init__(self, *args, **kwargs) -> None: ...
    def End(self) -> Time: ...
    @property
    def Ant(self) -> int: ...
    @property
    def Positions(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 5]']: ...
    @property
    def Space(self) -> int: ...
    @property
    def Start(self) -> Time: ...

class AntTrajectorySegment:
    def __init__(self, *args, **kwargs) -> None: ...
    def EndTime(self) -> Time: ...
    def StartTime(self) -> Time: ...
    @property
    def Begin(self) -> int: ...
    @property
    def End(self) -> int: ...
    @property
    def Trajectory(self) -> AntTrajectory: ...

class AntTrajectorySummary:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def Mean(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']: ...
    @property
    def Zones(self) -> set[int]: ...

class Capsule(Shape):
    C1: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']
    C2: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']
    R1: float
    R2: float
    def __init__(self, C1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'] = ..., C2: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'] = ..., R1: typing.SupportsFloat = ..., R2: typing.SupportsFloat = ...) -> None: ...

class Circle(Shape):
    Center: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']
    Radius: float
    def __init__(self, Center: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'] = ..., Radius: typing.SupportsFloat = ...) -> None: ...

class Collision:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def IDs(self) -> tuple[int, int]: ...
    @property
    def Types(self) -> typing.Annotated[numpy.typing.NDArray[numpy.uint32], '[m, 2]']: ...
    @property
    def Zone(self) -> int: ...

class CollisionFrame:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def Collisions(self) -> list[Collision]: ...
    @property
    def FrameTime(self) -> Time: ...
    @property
    def Space(self) -> int: ...

class ComputedMeasurement:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def LengthMM(self) -> float: ...
    @property
    def LengthPixel(self) -> float: ...
    @property
    def Time(self) -> Time: ...

class Duration:
    Hour: ClassVar[Duration] = ...  # read-only
    Microsecond: ClassVar[Duration] = ...  # read-only
    Millisecond: ClassVar[Duration] = ...  # read-only
    Minute: ClassVar[Duration] = ...  # read-only
    Second: ClassVar[Duration] = ...  # read-only
    @overload
    def __init__(self, ns: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, ns: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Hours(self) -> float: ...
    def Microseconds(self) -> float: ...
    def Milliseconds(self) -> float: ...
    def Minutes(self) -> float: ...
    def Nanoseconds(self) -> int: ...
    @staticmethod
    def Parse(d: str) -> Duration: ...
    def Seconds(self) -> float: ...
    @overload
    def __add__(self, arg0: Duration) -> Duration: ...
    @overload
    def __add__(self, arg0: typing.SupportsInt) -> Duration: ...
    def __eq__(self, arg0: Duration) -> bool: ...
    def __ge__(self, arg0: Duration) -> bool: ...
    def __gt__(self, arg0: Duration) -> bool: ...
    def __le__(self, arg0: Duration) -> bool: ...
    def __lt__(self, arg0: Duration) -> bool: ...
    @overload
    def __mul__(self, arg0: Duration) -> Duration: ...
    @overload
    def __mul__(self, arg0: typing.SupportsInt) -> Duration: ...
    def __radd__(self, arg0: typing.SupportsInt) -> Duration: ...
    def __rmul__(self, arg0: typing.SupportsInt) -> Duration: ...
    def __rsub__(self, arg0: typing.SupportsInt) -> Duration: ...
    @overload
    def __sub__(self, arg0: Duration) -> Duration: ...
    @overload
    def __sub__(self, arg0: typing.SupportsInt) -> Duration: ...

class Experiment:
    HEAD_TAIL_MEASUREMENT_TYPE_ID: ClassVar[int] = ...  # read-only
    Author: str
    Comment: str
    DefaultTagSize: float
    Name: str
    def __init__(self, filepath: str) -> None: ...
    def AddIdentification(self, antID: typing.SupportsInt, tagID: typing.SupportsInt, start: Time = ..., end: Time = ...) -> Identification: ...
    def AddTrackingDataDirectory(self, spaceID: typing.SupportsInt, filepath: str, fixCorruptedData: bool = ...) -> str: ...
    def CompileTrackingSolver(self, collisionsIgnoreZones: bool = ...) -> TrackingSolver: ...
    def CreateAnt(self) -> Ant: ...
    def CreateAntShapeType(self, name: str) -> int: ...
    def CreateMeasurementType(self, name: str) -> int: ...
    def CreateSpace(self, name: str) -> Space: ...
    def DeleteAnt(self, antID: typing.SupportsInt) -> None: ...
    def DeleteAntShapeType(self, antShapeTypeID: typing.SupportsInt) -> None: ...
    def DeleteIdentification(self, identification: Identification) -> None: ...
    def DeleteMeasurementType(self, measurementTypeID: typing.SupportsInt) -> None: ...
    def DeleteMetaDataKey(self, key: str) -> None: ...
    def DeleteSpace(self, spaceID: typing.SupportsInt) -> None: ...
    def EnsureAllDataIsLoaded(self, fixCorruptedData: bool = ...) -> None: ...
    def FreeIdentificationRangeAt(self, tagID: typing.SupportsInt, time: Time) -> tuple[Time, Time]: ...
    def IdentificationsAt(self, *args, **kwargs): ...
    @staticmethod
    def Open(filepath: str, fixCorruptedData: bool = ...) -> Experiment: ...
    @staticmethod
    def OpenDataLess(filepath: str) -> Experiment: ...
    def RemoveTrackingDataDirectory(self, URI: str) -> None: ...
    def RenameMetaDataKey(self, oldKey: str, newKey: str) -> None: ...
    def Save(self, filepath: str) -> None: ...
    def SetAntShapeTypeName(self, antShapeTypeID: typing.SupportsInt, name: str) -> None: ...
    def SetMeasurementTypeName(self, measurementTypeID: typing.SupportsInt, name: str) -> None: ...
    def SetMetaDataKey(self, key: str, defaultValue: bool | typing.SupportsInt | typing.SupportsFloat | str | Time) -> None: ...
    @property
    def AbsoluteFilePath(self) -> str: ...
    @property
    def AntShapeTypeNames(self) -> dict[int, str]: ...
    @property
    def Ants(self) -> dict[int, Ant]: ...
    @property
    def Family(self) -> TagFamily: ...
    @property
    def MeasurementTypeNames(self) -> dict[int, str]: ...
    @property
    def MetaDataKeys(self) -> dict[str, bool | int | float | str | Time]: ...
    @property
    def Spaces(self) -> dict[int, Space]: ...

class ExperimentDataInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def End(self) -> Time: ...
    @property
    def Frames(self) -> int: ...
    @property
    def Spaces(self) -> dict[int, SpaceDataInfo]: ...
    @property
    def Start(self) -> Time: ...

class FixableError(RuntimeError): ...

class Identification:
    DEFAULT_TAG_SIZE: ClassVar[float] = ...  # read-only
    End: Time
    Start: Time
    TagSize: float
    def __init__(self, *args, **kwargs) -> None: ...
    def ClearUserDefinedAntPose(self) -> None: ...
    def HasDefaultTagSize(self) -> bool: ...
    def HasUserDefinedAntPose(self) -> bool: ...
    def SetUserDefinedAntPose(self, antPosition: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'], antAngle: typing.SupportsFloat) -> None: ...
    @property
    def AntAngle(self) -> float: ...
    @property
    def AntPosition(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @property
    def TagValue(self) -> int: ...
    @property
    def TargetAntID(self) -> int: ...

class IdentifiedFrame:
    def __init__(self, *args, **kwargs) -> None: ...
    def At(self, index: typing.SupportsInt) -> tuple[int, typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]'], typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']]: ...
    def Contains(self, antID: typing.SupportsInt) -> bool: ...
    @property
    def FrameTime(self) -> Time: ...
    @property
    def Height(self) -> int: ...
    @property
    def Positions(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    @property
    def Space(self) -> int: ...
    @property
    def Width(self) -> int: ...

class Matcher:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def And(*args) -> Matcher: ...
    @staticmethod
    def AntAngleGreaterThan(angle: typing.SupportsFloat) -> Matcher: ...
    @staticmethod
    def AntAngleSmallerThan(angle: typing.SupportsFloat) -> Matcher: ...
    @staticmethod
    def AntDisplacement(under: typing.SupportsFloat, minimumGap: Duration = ...) -> Matcher: ...
    @staticmethod
    def AntDistanceGreaterThan(distance: typing.SupportsFloat) -> Matcher: ...
    @staticmethod
    def AntDistanceSmallerThan(distance: typing.SupportsFloat) -> Matcher: ...
    @staticmethod
    def AntID(antID: typing.SupportsInt) -> Matcher: ...
    @staticmethod
    def AntMetaData(key: str, value: bool | typing.SupportsInt | typing.SupportsFloat | str | Time | None) -> Matcher: ...
    @overload
    @staticmethod
    def InteractionType(type1: typing.SupportsInt, type2: typing.SupportsInt) -> Matcher: ...
    @overload
    @staticmethod
    def InteractionType(type1, type2) -> Any: ...
    @staticmethod
    def Or(*args) -> Matcher: ...

class OverlappingIdentification(RuntimeError): ...

class Polygon(Shape):
    Vertices: Vector2dList
    @overload
    def __init__(self, Vertices: Vector2dList) -> None: ...
    @overload
    def __init__(self) -> None: ...

class Query:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def CollideFrames(experiment: Experiment, start: Time = ..., end: Time = ..., zoneDepth: typing.SupportsInt = ..., zoneOrder: ZonePriority = ..., collisionsIgnoreZones: bool = ..., singleThreaded: bool = ..., reportProgress: bool = ..., onEachFrame: collections.abc.Callable[[tuple[IdentifiedFrame, CollisionFrame]], None] | None = ...) -> list | None: ...
    @staticmethod
    def ComputeAntInteractions(experiment: Experiment, start: Time = ..., end: Time = ..., maximumGap: Duration = ..., matcher: Matcher = ..., zoneDepth: typing.SupportsInt = ..., zoneOrder: ZonePriority = ..., collisionsIgnoreZones: bool = ..., reportFullTrajectories: bool = ..., segmentOnMatcherValueChange: bool = ..., singleThreaded: bool = ..., reportProgress: bool = ..., onNewTrajectory: collections.abc.Callable[[AntTrajectory], None] | None = ..., onNewInteraction: collections.abc.Callable[[AntInteraction], None] | None = ...) -> tuple[list, list] | None: ...
    @staticmethod
    def ComputeAntTrajectories(experiment: Experiment, start: Time = ..., end: Time = ..., maximumGap: Duration = ..., matcher: Matcher = ..., zoneDepth: typing.SupportsInt = ..., zoneOrder: ZonePriority = ..., segmentOnMatcherValueChange: bool = ..., singleThreaded: bool = ..., reportProgress: bool = ..., onNewTrajectory: collections.abc.Callable[[AntTrajectory], None] | None = ...) -> list | None: ...
    @staticmethod
    def ComputeMeasurementFor(experiment: Experiment, antID: typing.SupportsInt, measurementTypeID: typing.SupportsInt) -> list[ComputedMeasurement]: ...
    @staticmethod
    def ComputeTagStatistics(experiment: Experiment, fixCorruptedData: bool = ...) -> dict[int, TagStatistics]: ...
    @staticmethod
    def FindVideoSegments(experiment: Experiment, space: typing.SupportsInt = ..., start: Time = ..., end: Time = ...) -> VideoSegmentList: ...
    @staticmethod
    def GetDataInformations(experiment: Experiment) -> ExperimentDataInfo: ...
    @staticmethod
    def GetMetaDataKeyRanges(experiment: Experiment, key: str, value: bool | typing.SupportsInt | typing.SupportsFloat | str | Time) -> list[tuple[int, Time, Time]]: ...
    @staticmethod
    def GetTagCloseUps(experiment: Experiment, fixCorruptedData: bool = ...) -> object: ...
    @overload
    @staticmethod
    def IdentifyFrames(experiment: Experiment, start: Time = ..., end: Time = ..., singleThreaded: bool = ..., zoneDepth: typing.SupportsInt = ..., zoneOrder: ZonePriority = ..., reportProgress: bool = ..., onEachFrame: collections.abc.Callable[[IdentifiedFrame], None] | None = ...) -> list | None: ...
    @overload
    @staticmethod
    def IdentifyFrames() -> Any: ...

class Shape:
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        CAPSULE: ClassVar[Shape.Type] = ...
        CIRCLE: ClassVar[Shape.Type] = ...
        POLYGON: ClassVar[Shape.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ShapeType(self): ...

class ShapeList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: ShapeList) -> None: ...
    @overload
    def __init__(self, arg0: collections.abc.Iterable) -> None: ...
    def append(self, x: Shape) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: Shape) -> int: ...
    @overload
    def extend(self, L: ShapeList) -> None: ...
    @overload
    def extend(self, L: collections.abc.Iterable) -> None: ...
    def insert(self, i: typing.SupportsInt, x: Shape) -> None: ...
    @overload
    def pop(self) -> Shape: ...
    @overload
    def pop(self, i: typing.SupportsInt) -> Shape: ...
    def remove(self, x: Shape) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: Shape) -> bool: ...
    @overload
    def __delitem__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    def __eq__(self, arg0: ShapeList) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> ShapeList: ...
    @overload
    def __getitem__(self, arg0: typing.SupportsInt) -> Shape: ...
    def __iter__(self) -> collections.abc.Iterator[Shape]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: ShapeList) -> bool: ...
    @overload
    def __setitem__(self, arg0: typing.SupportsInt, arg1: Shape) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: ShapeList) -> None: ...

class Space:
    Name: str
    def __init__(self, *args, **kwargs) -> None: ...
    def CreateZone(self, name: str) -> Zone: ...
    def DeleteZone(self, zoneID: typing.SupportsInt) -> None: ...
    def LocateMovieFrame(self, time: Time) -> tuple[str, int]: ...
    @property
    def ID(self) -> int: ...
    @property
    def Zones(self) -> dict[int, Zone]: ...

class SpaceDataInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def End(self) -> Time: ...
    @property
    def Frames(self) -> int: ...
    @property
    def Name(self) -> str: ...
    @property
    def Start(self) -> Time: ...
    @property
    def TrackingDataDirectories(self) -> list[TrackingDataDirectoryInfo]: ...
    @property
    def URI(self) -> str: ...

class TagFamily:
    __members__: ClassVar[dict] = ...  # read-only
    Circle21h7: ClassVar[TagFamily] = ...
    Circle49h12: ClassVar[TagFamily] = ...
    Custom48h12: ClassVar[TagFamily] = ...
    Standard41h12: ClassVar[TagFamily] = ...
    Standard52h13: ClassVar[TagFamily] = ...
    Tag16h5: ClassVar[TagFamily] = ...
    Tag25h9: ClassVar[TagFamily] = ...
    Tag36ARTag: ClassVar[TagFamily] = ...
    Tag36h10: ClassVar[TagFamily] = ...
    Tag36h11: ClassVar[TagFamily] = ...
    Undefined: ClassVar[TagFamily] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TagStatistics:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def Counts(self) -> typing.Annotated[numpy.typing.NDArray[numpy.uint64], '[m, 1]']: ...
    @property
    def FirstSeen(self) -> Time: ...
    @property
    def ID(self) -> int: ...
    @property
    def LastSeen(self) -> Time: ...

class Time:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, timestamp: typing.SupportsFloat) -> None: ...
    def Add(self, d: Duration) -> Time: ...
    def After(self, other: Time) -> bool: ...
    def Before(self, other: Time) -> bool: ...
    def Equals(self, other: Time) -> bool: ...
    @staticmethod
    def Forever() -> Time: ...
    @staticmethod
    def FromDateTime(dt: object) -> Time: ...
    def IsForever(self) -> bool: ...
    def IsInfinite(self) -> bool: ...
    def IsSinceEver(self) -> bool: ...
    @staticmethod
    def Now() -> Time: ...
    @staticmethod
    def Parse(input: str) -> Time: ...
    def Reminder(self, d: Duration) -> Duration: ...
    def Round(self, d: Duration) -> Time: ...
    @staticmethod
    def SinceEver() -> Time: ...
    def Sub(self, arg0: Time) -> Duration: ...
    def ToDateTime(self) -> object: ...
    def ToTimestamp(self) -> float: ...
    @overload
    def __add__(self, arg0: Duration) -> Time: ...
    @overload
    def __add__(self, arg0: Duration) -> Time: ...
    def __eq__(self, arg0: Time) -> bool: ...
    def __ge__(self, arg0: Time) -> bool: ...
    def __gt__(self, arg0: Time) -> bool: ...
    def __le__(self, arg0: Time) -> bool: ...
    def __lt__(self, arg0: Time) -> bool: ...
    def __sub__(self, arg0: Time) -> Duration: ...

class TrackingDataDirectoryInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def AbsoluteFilePath(self) -> str: ...
    @property
    def End(self) -> Time: ...
    @property
    def Frames(self) -> int: ...
    @property
    def Start(self) -> Time: ...
    @property
    def URI(self) -> str: ...

class TrackingSolver:
    def __init__(self, *args, **kwargs) -> None: ...
    def CollideFrame(self, frame: IdentifiedFrame) -> CollisionFrame: ...
    def IdentifyAnt(self, tagID: typing.SupportsInt, time: Time) -> int: ...
    def IdentifyFrame(self, frameReadout: object, spaceID: typing.SupportsInt, zoneDepth: typing.SupportsInt = ..., zoneOrder: ZonePriority = ...) -> IdentifiedFrame: ...

class Value:
    @overload
    def __init__(self, arg0: bool) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: Time) -> None: ...

class ValueType:
    __members__: ClassVar[dict] = ...  # read-only
    BOOL: ClassVar[ValueType] = ...
    DOUBLE: ClassVar[ValueType] = ...
    INT: ClassVar[ValueType] = ...
    STRING: ClassVar[ValueType] = ...
    TIME: ClassVar[ValueType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Vector2dList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Vector2dList) -> None: ...
    @overload
    def __init__(self, arg0: collections.abc.Iterable) -> None: ...
    def append(self, x: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> int: ...
    @overload
    def extend(self, L: Vector2dList) -> None: ...
    @overload
    def extend(self, L: collections.abc.Iterable) -> None: ...
    def insert(self, i: typing.SupportsInt, x: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> None: ...
    @overload
    def pop(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @overload
    def pop(self, i: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    def remove(self, x: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> bool: ...
    @overload
    def __delitem__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    def __eq__(self, arg0: Vector2dList) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> Vector2dList: ...
    @overload
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    def __iter__(self) -> collections.abc.Iterator[typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Vector2dList) -> bool: ...
    @overload
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: Vector2dList) -> None: ...

class VideoFrameData:
    def __init__(self, position: typing.SupportsInt, time: Time) -> None: ...
    def Empty(self) -> bool: ...
    @property
    def Collided(self) -> CollisionFrame: ...
    @property
    def Identified(self) -> IdentifiedFrame: ...
    @property
    def Interactions(self) -> list[AntInteraction]: ...
    @property
    def Position(self) -> int: ...
    @property
    def Time(self) -> Time: ...
    @property
    def Trajectories(self) -> list[AntTrajectory]: ...

class VideoFrameDataList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VideoFrameDataList) -> None: ...
    @overload
    def __init__(self, arg0: collections.abc.Iterable) -> None: ...
    def append(self, x: VideoFrameData) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VideoFrameDataList) -> None: ...
    @overload
    def extend(self, L: collections.abc.Iterable) -> None: ...
    def insert(self, i: typing.SupportsInt, x: VideoFrameData) -> None: ...
    @overload
    def pop(self) -> VideoFrameData: ...
    @overload
    def pop(self, i: typing.SupportsInt) -> VideoFrameData: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VideoFrameDataList: ...
    @overload
    def __getitem__(self, arg0: typing.SupportsInt) -> VideoFrameData: ...
    def __iter__(self) -> collections.abc.Iterator[VideoFrameData]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: typing.SupportsInt, arg1: VideoFrameData) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VideoFrameDataList) -> None: ...

class VideoSegment:
    Data: VideoFrameDataList
    End: int
    def __init__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    @staticmethod
    def Match(segments: VideoSegmentList, identifiedFrames: collections.abc.Sequence[IdentifiedFrame]) -> None: ...
    @overload
    @staticmethod
    def Match(segments: VideoSegmentList, collisionData: collections.abc.Sequence[tuple[IdentifiedFrame, CollisionFrame]]) -> None: ...
    @overload
    @staticmethod
    def Match(segments: VideoSegmentList, trajectories: collections.abc.Sequence[AntTrajectory]) -> None: ...
    @overload
    @staticmethod
    def Match(segments: VideoSegmentList, interactions: collections.abc.Sequence[AntInteraction]) -> None: ...
    @property
    def AbsoluteFilePath(self) -> str: ...
    @property
    def Begin(self) -> int: ...
    @property
    def Space(self) -> int: ...

class VideoSegmentList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VideoSegmentList) -> None: ...
    @overload
    def __init__(self, arg0: collections.abc.Iterable) -> None: ...
    def append(self, x: VideoSegment) -> None: ...
    def clear(self) -> None: ...
    def deepcopy(self) -> VideoSegmentList: ...
    @overload
    def extend(self, L: VideoSegmentList) -> None: ...
    @overload
    def extend(self, L: collections.abc.Iterable) -> None: ...
    def insert(self, i: typing.SupportsInt, x: VideoSegment) -> None: ...
    @overload
    def pop(self) -> VideoSegment: ...
    @overload
    def pop(self, i: typing.SupportsInt) -> VideoSegment: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VideoSegmentList: ...
    @overload
    def __getitem__(self, arg0: typing.SupportsInt) -> VideoSegment: ...
    def __iter__(self) -> collections.abc.Iterator[VideoSegment]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: typing.SupportsInt, arg1: VideoSegment) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VideoSegmentList) -> None: ...

class VideoSequence:
    def __init__(self, arg0: VideoSegmentList) -> None: ...
    def __enter__(self) -> VideoSequence: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> bool: ...
    def __iter__(self) -> VideoSequence: ...
    def __next__(self) -> tuple: ...

class Zone:
    Name: str
    def __init__(self, *args, **kwargs) -> None: ...
    def AddDefinition(self, shapes: ShapeList = ..., start: Time = ..., end: Time = ...) -> ZoneDefinition: ...
    def DeleteDefinition(self, index: typing.SupportsInt) -> None: ...
    @property
    def Definitions(self) -> list[ZoneDefinition]: ...
    @property
    def ID(self) -> int: ...

class ZoneDefinition:
    End: Time
    Shapes: ShapeList
    Start: Time
    def __init__(self, *args, **kwargs) -> None: ...

class ZonePriority:
    __members__: ClassVar[dict] = ...  # read-only
    PREDECENCE_HIGHER: ClassVar[ZonePriority] = ...
    PREDECENCE_LOWER: ClassVar[ZonePriority] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def DefaultPalette() -> list[tuple[int, int, int]]: ...
def DefaultPaletteColor(index: typing.SupportsInt) -> tuple[int, int, int]: ...
def FormatAntID(antID: typing.SupportsInt) -> str: ...
def FormatTagID(tagID: typing.SupportsInt) -> str: ...
